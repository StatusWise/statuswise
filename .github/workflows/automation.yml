name: Automation

on:
  issues:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned, closed, reopened]
  pull_request:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned, closed, reopened, synchronize, ready_for_review]
  push:
    branches: [ main, develop ]

jobs:
  auto-label:
    name: Auto Label Issues and PRs
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' || github.event_name == 'pull_request'

    steps:
    - name: Auto label based on title and body
      uses: actions/github-script@v7
      with:
        script: |
          const { title, body } = context.payload[context.eventName];
          const labels = [];
          
          // Label based on keywords in title
          const titleLower = title.toLowerCase();
          if (titleLower.includes('bug') || titleLower.includes('fix')) {
            labels.push('bug');
          }
          if (titleLower.includes('feature') || titleLower.includes('enhancement')) {
            labels.push('enhancement');
          }
          if (titleLower.includes('documentation') || titleLower.includes('docs')) {
            labels.push('documentation');
          }
          if (titleLower.includes('security')) {
            labels.push('security');
          }
          if (titleLower.includes('performance')) {
            labels.push('performance');
          }
          
          // Label based on file changes (for PRs)
          if (context.eventName === 'pull_request') {
            const files = context.payload.pull_request.files;
            const fileExtensions = files.map(file => file.filename.split('.').pop());
            
            if (fileExtensions.some(ext => ['py', 'pyc'].includes(ext))) {
              labels.push('backend');
            }
            if (fileExtensions.some(ext => ['js', 'jsx', 'ts', 'tsx', 'css', 'html'].includes(ext))) {
              labels.push('frontend');
            }
            if (fileExtensions.some(ext => ['yml', 'yaml', 'dockerfile', 'docker-compose'].includes(ext))) {
              labels.push('devops');
            }
          }
          
          // Add labels if not already present
          const currentLabels = context.payload[context.eventName].labels.map(label => label.name);
          const newLabels = labels.filter(label => !currentLabels.includes(label));
          
          if (newLabels.length > 0) {
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: newLabels
            });
          }

  auto-assign:
    name: Auto Assign Issues and PRs
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' || github.event_name == 'pull_request'

    steps:
    - name: Auto assign based on labels
      uses: actions/github-script@v7
      with:
        script: |
          const labels = context.payload[context.eventName].labels.map(label => label.name);
          const assignees = [];
          
          // Assign based on labels
          if (labels.includes('backend')) {
            assignees.push('backend-maintainer');
          }
          if (labels.includes('frontend')) {
            assignees.push('frontend-maintainer');
          }
          if (labels.includes('devops')) {
            assignees.push('devops-maintainer');
          }
          if (labels.includes('security')) {
            assignees.push('security-team');
          }
          
          // Add assignees if not already assigned
          const currentAssignees = context.payload[context.eventName].assignees.map(assignee => assignee.login);
          const newAssignees = assignees.filter(assignee => !currentAssignees.includes(assignee));
          
          if (newAssignees.length > 0) {
            await github.rest.issues.addAssignees({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              assignees: newAssignees
            });
          }

  stale-issues:
    name: Mark Stale Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'

    steps:
    - name: Mark stale issues
      uses: actions/stale@v8
      with:
        repo-token: ${{ secrets.GITHUB_TOKEN }}
        stale-issue-message: |
          This issue has been automatically marked as stale because it has not had recent activity.
          It will be closed if no further activity occurs. Thank you for your contributions.
        stale-issue-label: 'no-remove'
        stale-pr-message: |
          This pull request has been automatically marked as stale because it has not had recent activity.
          It will be closed if no further activity occurs. Thank you for your contributions.
        stale-pr-label: 'no-remove'
        stale-days: 30
        exempt-issue-labels: 'pinned,security,bug,enhancement'
        exempt-pr-labels: 'pinned,security,bug,enhancement'
        exempt-all-milestones: true

  dependency-updates:
    name: Check for Dependency Updates
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check Python dependencies
      run: |
        cd backend
        pip install pip-check-updates
        pcu --dry-run > python-updates.txt || echo "No updates available" > python-updates.txt

    - name: Check Node.js dependencies
      run: |
        cd frontend
        npm outdated --json > npm-updates.json || echo '{}' > npm-updates.json

    - name: Create issue for dependency updates
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          let issueBody = '## ðŸ”„ Dependency Updates Available\n\n';
          issueBody += 'This issue was automatically generated to track available dependency updates.\n\n';
          
          // Check Python updates
          try {
            const pythonUpdates = fs.readFileSync('backend/python-updates.txt', 'utf8');
            if (pythonUpdates && !pythonUpdates.includes('No updates available')) {
              issueBody += '### Python Dependencies\n\n';
              issueBody += '```\n' + pythonUpdates + '\n```\n\n';
            }
          } catch (e) {
            console.log('No Python updates found');
          }
          
          // Check Node.js updates
          try {
            const npmUpdates = JSON.parse(fs.readFileSync('frontend/npm-updates.json', 'utf8'));
            if (Object.keys(npmUpdates).length > 0) {
              issueBody += '### Node.js Dependencies\n\n';
              Object.entries(npmUpdates).forEach(([package, info]) => {
                issueBody += `- **${package}**: ${info.current} â†’ ${info.latest}\n`;
              });
              issueBody += '\n';
            }
          } catch (e) {
            console.log('No Node.js updates found');
          }
          
          issueBody += '### ðŸ“‹ Action Items\n\n';
          issueBody += '- [ ] Review security implications\n';
          issueBody += '- [ ] Test compatibility\n';
          issueBody += '- [ ] Update dependencies\n';
          issueBody += '- [ ] Update lock files\n\n';
          issueBody += '---\n';
          issueBody += '*This issue was automatically generated by GitHub Actions*';
          
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `Dependency Updates - ${new Date().toISOString().split('T')[0]}`,
            body: issueBody,
            labels: ['dependencies', 'automated', 'maintenance']
          });

  pr-checks:
    name: PR Quality Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
    - name: Check PR size
      uses: actions/github-script@v7
      with:
        script: |
          const { additions, deletions } = context.payload.pull_request;
          const totalChanges = additions + deletions;
          
          let comment = '## ðŸ“Š PR Analysis\n\n';
          comment += `**Changes**: +${additions} -${deletions} (${totalChanges} total)\n\n`;
          
          if (totalChanges > 1000) {
            comment += 'âš ï¸ **Large PR detected** - Consider breaking this into smaller, more manageable PRs.\n\n';
          }
          
          if (additions > deletions * 3) {
            comment += 'âš ï¸ **High addition-to-deletion ratio** - Consider if all additions are necessary.\n\n';
          }
          
          comment += '### ðŸ“‹ Checklist\n\n';
          comment += '- [ ] Code follows project style guidelines\n';
          comment += '- [ ] Tests added/updated\n';
          comment += '- [ ] Documentation updated\n';
          comment += '- [ ] No breaking changes (or breaking changes documented)\n';
          comment += '- [ ] Security considerations addressed\n\n';
          comment += '---\n';
          comment += '*This analysis was automatically generated*';
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

  release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - name: Generate release notes
      uses: actions/github-script@v7
      with:
        script: |
          const { data: commits } = await github.rest.repos.compareCommits({
            owner: context.repo.owner,
            repo: context.repo.repo,
            base: 'main~1',
            head: 'main'
          });
          
          let releaseNotes = '## ðŸš€ Release Notes\n\n';
          releaseNotes += `**Version**: ${new Date().toISOString().split('T')[0]}\n\n`;
          
          const categories = {
            'feat': 'ðŸš€ Features',
            'fix': 'ðŸ› Bug Fixes',
            'docs': 'ðŸ“š Documentation',
            'style': 'ðŸ’„ Style',
            'refactor': 'â™»ï¸ Refactoring',
            'perf': 'âš¡ Performance',
            'test': 'ðŸ§ª Tests',
            'chore': 'ðŸ”§ Chores'
          };
          
          const categorized = {};
          
          commits.commits.forEach(commit => {
            const message = commit.commit.message;
            const match = message.match(/^(\w+)(?:\(([\w\-]+)\))?:\s*(.+)/);
            
            if (match) {
              const [, type, scope, description] = match;
              const category = categories[type] || 'ðŸ“ Other';
              
              if (!categorized[category]) {
                categorized[category] = [];
              }
              
              const scopeText = scope ? `**${scope}**: ` : '';
              categorized[category].push(`- ${scopeText}${description}`);
            }
          });
          
          Object.keys(categorized).forEach(category => {
            if (categorized[category].length > 0) {
              releaseNotes += `### ${category}\n\n`;
              categorized[category].forEach(item => {
                releaseNotes += `${item}\n`;
              });
              releaseNotes += '\n';
            }
          });
          
          // Create a draft release
          await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: `v${new Date().toISOString().split('T')[0]}`,
            name: `Release ${new Date().toISOString().split('T')[0]}`,
            body: releaseNotes,
            draft: true,
            prerelease: false
          }); 