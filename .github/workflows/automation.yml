name: Automation

permissions: write-all

on:
  issues:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned, closed, reopened]
  pull_request:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned, closed, reopened, synchronize, ready_for_review]
  push:
    branches: [ main, develop ]

jobs:
  auto-label:
    name: Auto Label Issues and PRs
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' || github.event_name == 'pull_request'

    steps:
    - name: Auto label based on title and body
      uses: actions/github-script@v7
      with:
        script: |
          const { title, body } = context.payload[context.eventName];
          const labels = [];
          
          // Label based on keywords in title
          const titleLower = title.toLowerCase();
          if (titleLower.includes('bug') || titleLower.includes('fix')) {
            labels.push('bug');
          }
          if (titleLower.includes('feature') || titleLower.includes('enhancement')) {
            labels.push('enhancement');
          }
          if (titleLower.includes('documentation') || titleLower.includes('docs')) {
            labels.push('documentation');
          }
          if (titleLower.includes('security')) {
            labels.push('security');
          }
          if (titleLower.includes('performance')) {
            labels.push('performance');
          }
          
          // Label based on file changes (for PRs)
          if (context.eventName === 'pull_request') {
            const files = context.payload.pull_request.files;
            const fileExtensions = files.map(file => file.filename.split('.').pop());
            
            if (fileExtensions.some(ext => ['py', 'pyc'].includes(ext))) {
              labels.push('backend');
            }
            if (fileExtensions.some(ext => ['js', 'jsx', 'ts', 'tsx', 'css', 'html'].includes(ext))) {
              labels.push('frontend');
            }
            if (fileExtensions.some(ext => ['yml', 'yaml', 'dockerfile', 'docker-compose'].includes(ext))) {
              labels.push('devops');
            }
          }
          
          // Add labels if not already present
          const currentLabels = context.payload[context.eventName].labels.map(label => label.name);
          const newLabels = labels.filter(label => !currentLabels.includes(label));
          
          if (newLabels.length > 0) {
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: newLabels
            });
          }

  auto-assign:
    name: Auto Assign Issues and PRs
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' || github.event_name == 'pull_request'

    steps:
    - name: Auto assign based on labels
      uses: actions/github-script@v7
      with:
        script: |
          const labels = context.payload[context.eventName].labels.map(label => label.name);
          const assignees = [];
          
          // Assign based on labels
          if (labels.includes('backend')) {
            assignees.push('backend-maintainer');
          }
          if (labels.includes('frontend')) {
            assignees.push('frontend-maintainer');
          }
          if (labels.includes('devops')) {
            assignees.push('devops-maintainer');
          }
          if (labels.includes('security')) {
            assignees.push('security-team');
          }
          
          // Add assignees if not already assigned
          const currentAssignees = context.payload[context.eventName].assignees.map(assignee => assignee.login);
          const newAssignees = assignees.filter(assignee => !currentAssignees.includes(assignee));
          
          if (newAssignees.length > 0) {
            await github.rest.issues.addAssignees({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              assignees: newAssignees
            });
          }

  stale-issues:
    name: Mark Stale Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'

    steps:
    - name: Mark stale issues
      uses: actions/stale@v8
      with:
        repo-token: ${{ secrets.GITHUB_TOKEN }}
        stale-issue-message: |
          This issue has been automatically marked as stale because it has not had recent activity.
          It will be closed if no further activity occurs. Thank you for your contributions.
        stale-issue-label: 'no-remove'
        stale-pr-message: |
          This pull request has been automatically marked as stale because it has not had recent activity.
          It will be closed if no further activity occurs. Thank you for your contributions.
        stale-pr-label: 'no-remove'
        days-before-stale: 30
        exempt-issue-labels: 'pinned,security,bug,enhancement'
        exempt-pr-labels: 'pinned,security,bug,enhancement'
        exempt-all-milestones: true

  dependency-updates:
    name: Check for Dependency Updates
    runs-on: ubuntu-latest
    

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check Python dependencies
      run: |
        cd backend
        pip install --upgrade pip-check-updates
        pcu > python-updates.txt || echo "No updates available" > python-updates.txt

    - name: Check Node.js dependencies
      run: |
        cd frontend
        npm outdated --json > npm-updates.json || echo '{}' > npm-updates.json

    - name: Create or update issue for dependency updates
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const issueTitle = 'Dependency Updates Available';
          
          let issueBody = `## 🔄 ${issueTitle}\n\n`;
          issueBody += 'This issue was automatically generated to track available dependency updates.\n\n';
          
          let hasUpdates = false;
          
          // Check Python updates
          try {
            const pythonUpdates = fs.readFileSync('backend/python-updates.txt', 'utf8');
            if (pythonUpdates && !pythonUpdates.includes('No updates available') && pythonUpdates.trim() !== '') {
              issueBody += '### Python Dependencies\n\n';
              issueBody += '```\n' + pythonUpdates + '\n```\n\n';
              hasUpdates = true;
            }
          } catch (e) {
            console.log('Could not read Python updates file.');
          }
          
          // Check Node.js updates
          try {
            const npmUpdates = JSON.parse(fs.readFileSync('frontend/npm-updates.json', 'utf8'));
            if (Object.keys(npmUpdates).length > 0) {
              issueBody += '### Node.js Dependencies\n\n';
              issueBody += '| Package | Current | Latest |\n';
              issueBody += '|---|---|---|\n';
              Object.entries(npmUpdates).forEach(([pkg, info]) => {
                issueBody += `| ${pkg} | ${info.current} | ${info.latest} |\n`;
              });
              issueBody += '\n';
              hasUpdates = true;
            }
          } catch (e) {
            console.log('Could not read or parse Node.js updates file.');
          }
          
          if (!hasUpdates) {
            console.log('No dependency updates found.');
            return;
          }
          
          issueBody += '### 📋 Action Items\n\n';
          issueBody += '- [ ] Review security implications\n';
          issueBody += '- [ ] Test compatibility\n';
          issueBody += '- [ ] Update dependencies\n';
          issueBody += '- [ ] Update lock files\n\n';
          issueBody += '---\n';
          issueBody += '*This issue was automatically generated by GitHub Actions*';

          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: 'dependencies'
          });

          const existingIssue = issues.find(issue => issue.title === issueTitle);

          if (existingIssue) {
            // Update the existing issue
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existingIssue.number,
              body: issueBody
            });
            console.log(`Updated issue #${existingIssue.number}`);
          } else {
            // Create a new issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: ['dependencies', 'automated', 'maintenance']
            });
            console.log('Created a new dependency update issue.');
          }

  pr-checks:
    name: PR Quality Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
    - name: Check PR size
      uses: actions/github-script@v7
      with:
        script: |
          const { additions, deletions } = context.payload.pull_request;
          const totalChanges = additions + deletions;
          
          let comment = '## 📊 PR Analysis\n\n';
          comment += `**Changes**: +${additions} -${deletions} (${totalChanges} total)\n\n`;
          
          if (totalChanges > 1000) {
            comment += '⚠️ **Large PR detected** - Consider breaking this into smaller, more manageable PRs.\n\n';
          }
          
          if (additions > deletions * 3) {
            comment += '⚠️ **High addition-to-deletion ratio** - Consider if all additions are necessary.\n\n';
          }
          
          comment += '### 📋 Checklist\n\n';
          comment += '- [ ] Code follows project style guidelines\n';
          comment += '- [ ] Tests added/updated\n';
          comment += '- [ ] Documentation updated\n';
          comment += '- [ ] No breaking changes (or breaking changes documented)\n';
          comment += '- [ ] Security considerations addressed\n\n';
          comment += '---\n';
          comment += '*This analysis was automatically generated*';
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          }); 